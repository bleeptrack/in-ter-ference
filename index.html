<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paper.js + feat.js Demo</title>
    <style>
        html,
        body {
            padding: 0;
            margin: 0;
            width: 100%;
            height: 100%;
        }
        
        
        .demo-section{
            height: 29%;
        }

        .demo-section canvas{
            border: 1px solid white;
        }
        
        
        /* Scale canvas with resize attribute to full size */
        .container{
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: row;
            align-items: center;
        }

        #paper-canvas{
            width: 100%;
            height: 100%;
        }

        #settings-section{
            width: 25vw;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            position: fixed;
            top: 0;
            left: 0;
            margin: 1vh;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }

        #status {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 30px;
            width: 640px;
        }

        #status-emoji{
            font-size: 10em;
            display: block;
            text-align: center;
        }

        #status-text{
            font-family: 'Arial', sans-serif;
            text-align: center;
            margin: 0;
        }

    </style>
</head>
<body>
    <div class="container">
        
        
        <div id="settings-section"> 
            <div class="demo-section" id="demo-webcam">
                
                <div style="position: relative; display: inline-block;">
                    <video id="webcam-video" width="640" height="480" autoplay muted></video>
                    <canvas id="overlay-canvas" width="640" height="480" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
                </div>
            </div>
            
            <div class="demo-section" id="demo-rectified">
                <canvas id="rectified-canvas" width="640" height="480" ></canvas>
            </div>

            <div class="demo-section" id="status">
                <span id="status-emoji"></span>
                <h1 id="status-text"></h1>
            </div>

        </div>  

        <canvas id="paper-canvas" hidpi="off"></canvas>
    </div>

    <!-- Include Paper.js -->
    <script type="text/javascript" src="node_modules/paper/dist/paper-full.min.js"></script>
    
    <!-- Include jsfeat -->
    <script type="text/javascript" src="node_modules/jsfeat/build/jsfeat.js"></script>
    
    <!-- Include Sketch.js -->
    <script type="text/javascript" src="Sketch.js"></script>
    
    <script>
        // Paper.js setup
        paper.install(window);
        
            // Webcam setup and point selection - declare variables first
            let stream = null;
            let selectedPoints = [];
            let isSelectingPoints = false;
            let overlayCanvas, overlayCtx;
            let rectifiedCanvas, rectifiedCtx;
            let isDragging = false;
            let draggedPointIndex = -1;
            let dragOffset = { x: 0, y: 0 };
            let edgeDetectionEnabled = false;
            
            // Variables for draggable points on rectified canvas
            let rectifiedPoints = [
                { x: 128, y: 240 }, // First point (20% from left, middle height)
                { x: 512, y: 240 }  // Second point (80% from left, middle height)
            ];
            let isDraggingRectifiedPoint = false;
            let draggedRectifiedPointIndex = -1;
            let rectifiedDragOffset = { x: 0, y: 0 };
            
            // Array to store perpendicular line analysis results
            let perpendicularLineResults = [];
            
            // Threshold for detecting significant changes between readings
            let changeThreshold = 250.0; // pixels
            
            // Visual debugging
            let visualDebugEnabled = false;
            
            // Stability detection
            let consecutiveStableReadings = 0;
            let requiredStableReadings = 3;
            let stabilityReached = false; // Track if stability has been achieved
            
            // Performance settings for Jetson Nano optimization (defaulted to ultra-low performance mode)
            let edgeDetectionIntervalMs = 1500; // Default 1500ms interval for maximum performance
            let useReducedResolution = true; // Default to reduced resolution for Jetson Nano
            let reducedResolutionFactor = 0.3; // Reduce to 30% resolution for maximum speed
            let optimizedCannyThresholds = { low: 20, high: 80 }; // Lower thresholds for fastest processing
            let reducedPerpendicularLines = 15; // Standard 15 lines for good analysis
            
            // Rectification optimization settings
            let useReducedRectificationResolution = true; // Enable reduced resolution for rectification
            let rectificationResolutionFactor = 0.25; // Reduce rectification to 25% resolution for maximum speed
            let useNearestNeighborInterpolation = true; // Use fastest interpolation by default
            
            // Initialize Paper.js when the page loads
            window.onload = function() {
                // Set up Paper.js canvas
                const canvas = document.getElementById('paper-canvas');
                paper.setup(canvas);
                
                // Initialize Sketch.js code
                initializeSketch();

                
                // Call the sketch initialization after Paper.js is ready
                if (window.sketchVars && window.sketchVars.init) {
                    window.sketchVars.init();
                }
                
                
                
                // Initialize overlay and rectified canvases
                overlayCanvas = document.getElementById('overlay-canvas');
                overlayCtx = overlayCanvas.getContext('2d');
                
                rectifiedCanvas = document.getElementById('rectified-canvas');
                rectifiedCtx = rectifiedCanvas.getContext('2d');
                
                // Add mouse event handlers for rectified canvas
                setupRectifiedCanvasInteraction();
                
                // Auto-start webcam
                startWebcam();
                
                // Load saved points
                loadSavedPoints();
            };
            
            function startWebcam() {
                navigator.mediaDevices.getUserMedia({ video: true })
                    .then(function(mediaStream) {
                        stream = mediaStream;
                        const video = document.getElementById('webcam-video');
                        video.srcObject = stream;
                        
                        
                        // Initialize feat.js when video starts playing
                        video.onloadedmetadata = function() {
                            console.log('Webcam started, feat.js ready for face detection');
                            
                            // If we have saved points, start live rectification now that video is ready
                            if (selectedPoints.length === 4) {
                                startLiveRectification();
                            } else if (selectedPoints.length === 0) {
                                // No points set yet, set default triangulation points now that video is ready
                                // Add a small delay to ensure the video element is properly rendered
                                setTimeout(() => {
                                    setDefaultTriangulationPoints();
                                }, 100);
                            }
                        };
                    })
                    .catch(function(err) {
                        console.error('Error accessing webcam:', err);
                        alert('Could not access webcam. Please check permissions.');
                    });
            }
            
            
            
            
            
            
            
            // Video mouse event handlers for point selection and dragging
            const video = document.getElementById('webcam-video');
                
            video.onmousedown = function(event) {
                const rect = event.target.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // Check if clicking on an existing point
                if (selectedPoints.length > 0) {
                    for (let i = 0; i < selectedPoints.length; i++) {
                        const point = selectedPoints[i];
                        const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                        if (distance <= 15) { // 15 pixel radius for dragging
                            isDragging = true;
                            draggedPointIndex = i;
                            dragOffset.x = x - point.x;
                            dragOffset.y = y - point.y;
                            return;
                        }
                    }
                }
                
                // If not dragging and in selection mode, add new point
                if (isSelectingPoints && selectedPoints.length < 4) {
                selectedPoints.push({x: x, y: y});
                drawPoint(x, y, selectedPoints.length);
                updatePointStatus();
                
                if (selectedPoints.length === 4) {
                    isSelectingPoints = false;
                        
                        // Automatically enable edge detection
                        edgeDetectionEnabled = true;
                    drawTrapezoid();
                    
                    // Auto-save points when 4 are selected
                    savePoints();
                        
                            // Show rectified section and start live preview
                            document.getElementById('rectified-section').style.display = 'block';
                            startLiveRectification();
                            
                            // Draw the draggable points and line
                            setTimeout(() => {
                                drawRectifiedPointsAndLine();
                            }, 100);
                            
                            // Initialize stability detection for new points
                            console.log(`üîÑ Stability detection initialized for new points`);
                            console.log(`üìä Current threshold: ${changeThreshold}px, Required stable readings: ${requiredStableReadings}`);
                    }
                }
            };
            
            video.onmousemove = function(event) {
                if (!isDragging) return;
                
                const rect = event.target.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // Update the dragged point position
                selectedPoints[draggedPointIndex].x = x - dragOffset.x;
                selectedPoints[draggedPointIndex].y = y - dragOffset.y;
                
                // Redraw overlay
                clearOverlay();
                for (let i = 0; i < selectedPoints.length; i++) {
                    drawPoint(selectedPoints[i].x, selectedPoints[i].y, i + 1);
                }
                if (selectedPoints.length === 4) {
                    drawTrapezoid();
                }
                
                // Update live rectification if we have 4 points
                if (selectedPoints.length === 4) {
                    updateLiveRectification();
                }
            };
            
            video.onmouseup = function(event) {
                if (isDragging) {
                    isDragging = false;
                    draggedPointIndex = -1;
                    dragOffset = { x: 0, y: 0 };
                    
                    // Save updated points
                    if (selectedPoints.length === 4) {
                        savePoints();
                    }
                }
            };
            
            video.onmouseleave = function(event) {
                // Stop dragging if mouse leaves the video area
                if (isDragging) {
                    isDragging = false;
                    draggedPointIndex = -1;
                    dragOffset = { x: 0, y: 0 };
                }
            };
            
            function drawPoint(x, y, number) {
                overlayCtx.fillStyle = '#ff0000';
                overlayCtx.beginPath();
                overlayCtx.arc(x, y, 8, 0, 2 * Math.PI);
                overlayCtx.fill();
                
                overlayCtx.fillStyle = '#ffffff';
                overlayCtx.font = '12px Arial';
                overlayCtx.textAlign = 'center';
                overlayCtx.fillText(number, x, y + 4);
            }
            
            function drawTrapezoid() {
                if (selectedPoints.length !== 4) return;
                
                // Sort points to ensure proper order: top-left, top-right, bottom-right, bottom-left
                const sortedPoints = sortPointsClockwise(selectedPoints);
                
                overlayCtx.strokeStyle = '#00ff00';
                overlayCtx.lineWidth = 2;
                overlayCtx.beginPath();
                
                for (let i = 0; i < 4; i++) {
                    const point = sortedPoints[i];
                    if (i === 0) {
                        overlayCtx.moveTo(point.x, point.y);
                    } else {
                        overlayCtx.lineTo(point.x, point.y);
                    }
                }
                overlayCtx.closePath();
                overlayCtx.stroke();
            }
            
            function sortPointsClockwise(points) {
                // Calculate center point
                const centerX = points.reduce((sum, p) => sum + p.x, 0) / 4;
                const centerY = points.reduce((sum, p) => sum + p.y, 0) / 4;
                
                // Sort by angle from center
                return points.sort((a, b) => {
                    const angleA = Math.atan2(a.y - centerY, a.x - centerX);
                    const angleB = Math.atan2(b.y - centerY, b.x - centerX);
                    return angleA - angleB;
                });
            }
            
            function clearOverlay() {
                overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            }
            
            function updatePointStatus() {
                
            }
            
            function savePoints() {
                if (selectedPoints.length === 4) {
                    localStorage.setItem('savedPoints', JSON.stringify(selectedPoints));
                    console.log('Points saved to localStorage');
                }
            }
            
            function saveRectifiedPoints() {
                localStorage.setItem('savedRectifiedPoints', JSON.stringify(rectifiedPoints));
                console.log('Rectified points saved to localStorage');
            }
            
            function setDefaultTriangulationPoints() {
                // Set default triangulation points that form a reasonable trapezoid
                // These points are positioned to cover a typical screen area
                const video = document.getElementById('webcam-video');
                
                // Use the display dimensions of the video element, not the video stream dimensions
                const displayWidth = video ? video.offsetWidth : 640;
                const displayHeight = video ? video.offsetHeight : 480;
                
                // Create a trapezoid that covers most of the video display area
                // Top-left, top-right, bottom-right, bottom-left
                selectedPoints = [
                    { x: displayWidth * 0.1, y: displayHeight * 0.1 },      // top-left
                    { x: displayWidth * 0.9, y: displayHeight * 0.1 },      // top-right
                    { x: displayWidth * 0.8, y: displayHeight * 0.9 },      // bottom-right
                    { x: displayWidth * 0.2, y: displayHeight * 0.9 }       // bottom-left
                ];
                
                console.log('Set default triangulation points:', selectedPoints);
                console.log('Video display dimensions:', displayWidth, 'x', displayHeight);
                
                // Draw the default points and trapezoid
                clearOverlay();
                for (let i = 0; i < selectedPoints.length; i++) {
                    drawPoint(selectedPoints[i].x, selectedPoints[i].y, i + 1);
                }
                drawTrapezoid();
                
                // Automatically enable edge detection
                edgeDetectionEnabled = true;
                
                // Save the default points
                savePoints();
                
                // Start live rectification if webcam is ready
                if (video && video.videoWidth > 0 && video.videoHeight > 0) {
                    startLiveRectification();
                    
                    // Draw the draggable points and line
                    setTimeout(() => {
                        drawRectifiedPointsAndLine();
                    }, 100);
                    
                    // Initialize stability detection for default points
                    console.log(`üîÑ Stability detection initialized with default points`);
                    console.log(`üìä Current threshold: ${changeThreshold}px, Required stable readings: ${requiredStableReadings}`);
                }
            }
            
            function loadSavedPoints() {
                const saved = localStorage.getItem('savedPoints');
                if (saved) {
                    try {
                        selectedPoints = JSON.parse(saved);
                        console.log('Loaded saved points:', selectedPoints);
                        
                        // Redraw the points and trapezoid if we have 4 points
                        if (selectedPoints.length === 4) {
                            clearOverlay();
                            for (let i = 0; i < selectedPoints.length; i++) {
                                drawPoint(selectedPoints[i].x, selectedPoints[i].y, i + 1);
                            }
                            drawTrapezoid();
                            updatePointStatus();
                            
                           
                            
                            // Automatically enable edge detection
                            edgeDetectionEnabled = true;
                            
                            
                            // Start live rectification only if webcam is ready
                            const video = document.getElementById('webcam-video');
                            if (video && video.videoWidth > 0 && video.videoHeight > 0) {
                                startLiveRectification();
                                
                                // Draw the draggable points and line
                                setTimeout(() => {
                                    drawRectifiedPointsAndLine();
                                }, 100);
                                
                                // Initialize stability detection for loaded points
                                console.log(`üîÑ Stability detection initialized on page load`);
                                console.log(`üìä Current threshold: ${changeThreshold}px, Required stable readings: ${requiredStableReadings}`);
                            }
                        }
                    } catch (e) {
                        console.error('Error loading saved points:', e);
                    }
                } else {
                    // No saved points found, set default triangulation points
                    setDefaultTriangulationPoints();
                }
                
                // Load saved rectified points
                loadSavedRectifiedPoints();
            }
            
            function loadSavedRectifiedPoints() {
                const saved = localStorage.getItem('savedRectifiedPoints');
                if (saved) {
                    try {
                        rectifiedPoints = JSON.parse(saved);
                        console.log('Loaded saved rectified points:', rectifiedPoints);
                    } catch (e) {
                        console.error('Error loading saved rectified points:', e);
                        // Reset to default positions if loading fails
                        setDefaultGreenLinePoints();
                    }
                } else {
                    // No saved rectified points found, set default green line points
                    setDefaultGreenLinePoints();
                }
            }
            
            function setDefaultGreenLinePoints() {
                // Set default green line points that are well-positioned for edge detection
                const rectifiedCanvas = document.getElementById('rectified-canvas');
                const canvasWidth = rectifiedCanvas ? rectifiedCanvas.width : 640;
                const canvasHeight = rectifiedCanvas ? rectifiedCanvas.height : 480;
                
                // Create a horizontal line across the middle of the canvas
                rectifiedPoints = [
                    { x: canvasWidth * 0.2, y: canvasHeight * 0.5 },   // Left point
                    { x: canvasWidth * 0.8, y: canvasHeight * 0.5 }    // Right point
                ];
                
                console.log('Set default green line points:', rectifiedPoints);
                
                // Save the default points
                saveRectifiedPoints();
            }
            
            function resetToDefaultPoints() {
                // Clear all saved points and reset to defaults
                localStorage.removeItem('savedPoints');
                localStorage.removeItem('savedRectifiedPoints');
                
                // Clear current points
                selectedPoints = [];
                rectifiedPoints = [];
                
                // Clear overlay
                clearOverlay();
                
                // Reset to default points
                setDefaultTriangulationPoints();
                setDefaultGreenLinePoints();
                
                console.log('Reset to default points');
            }
            
            function forceDefaultPoints() {
                // Force set default points regardless of saved state
                console.log('Forcing default points...');
                setDefaultTriangulationPoints();
                setDefaultGreenLinePoints();
            }
            
            // Performance control functions for Jetson Nano optimization
            function setPerformanceMode(mode) {
                switch(mode) {
                    case 'high':
                        edgeDetectionIntervalMs = 200;
                        useReducedResolution = false;
                        useReducedRectificationResolution = false;
                        useNearestNeighborInterpolation = false;
                        reducedPerpendicularLines = 20;
                        optimizedCannyThresholds = { low: 50, high: 150 };
                        console.log('Set to HIGH performance mode (fastest processing, highest quality)');
                        break;
                    case 'medium':
                        edgeDetectionIntervalMs = 500;
                        useReducedResolution = false;
                        useReducedRectificationResolution = true;
                        rectificationResolutionFactor = 0.7;
                        useNearestNeighborInterpolation = false;
                        reducedPerpendicularLines = 15;
                        optimizedCannyThresholds = { low: 40, high: 120 };
                        console.log('Set to MEDIUM performance mode (balanced quality/speed)');
                        break;
                    case 'low':
                        edgeDetectionIntervalMs = 1000;
                        useReducedResolution = true;
                        reducedResolutionFactor = 0.5;
                        useReducedRectificationResolution = true;
                        rectificationResolutionFactor = 0.5;
                        useNearestNeighborInterpolation = true;
                        reducedPerpendicularLines = 10;
                        optimizedCannyThresholds = { low: 30, high: 100 };
                        console.log('Set to LOW performance mode (fastest, optimized for Jetson Nano)');
                        break;
                    case 'ultra-low':
                        edgeDetectionIntervalMs = 1500;
                        useReducedResolution = true;
                        reducedResolutionFactor = 0.3;
                        useReducedRectificationResolution = true;
                        rectificationResolutionFactor = 0.3;
                        useNearestNeighborInterpolation = true;
                        reducedPerpendicularLines = 5;
                        optimizedCannyThresholds = { low: 20, high: 80 };
                        console.log('Set to ULTRA-LOW performance mode (maximum speed, lowest quality)');
                        break;
                    default:
                        console.log('Available modes: high, medium, low, ultra-low');
                }
                
                // Restart the interval with new timing
                if (liveRectificationInterval) {
                    clearInterval(liveRectificationInterval);
                    liveRectificationInterval = setInterval(() => {
                        if (selectedPoints.length === 4) {
                            updateLiveRectification();
                            updateEdgeDetection();
                        }
                    }, edgeDetectionIntervalMs);
                }
            }
            
            function getPerformanceSettings() {
                return {
                    interval: edgeDetectionIntervalMs,
                    reducedResolution: useReducedResolution,
                    resolutionFactor: reducedResolutionFactor,
                    perpendicularLines: reducedPerpendicularLines,
                    cannyThresholds: optimizedCannyThresholds
                };
            }
            
            function setEdgeDetectionInterval(ms) {
                edgeDetectionIntervalMs = ms;
                console.log(`Edge detection interval set to ${ms}ms`);
                
                // Restart the interval with new timing
                if (liveRectificationInterval) {
                    clearInterval(liveRectificationInterval);
                    liveRectificationInterval = setInterval(() => {
                        if (selectedPoints.length === 4) {
                            updateLiveRectification();
                            updateEdgeDetection();
                        }
                    }, edgeDetectionIntervalMs);
                }
            }
            
            function toggleReducedResolution() {
                useReducedResolution = !useReducedResolution;
                console.log(`Reduced resolution ${useReducedResolution ? 'enabled' : 'disabled'}`);
                return useReducedResolution;
            }
            
            function toggleReducedRectificationResolution() {
                useReducedRectificationResolution = !useReducedRectificationResolution;
                console.log(`Reduced rectification resolution ${useReducedRectificationResolution ? 'enabled' : 'disabled'}`);
                return useReducedRectificationResolution;
            }
            
            function setRectificationResolutionFactor(factor) {
                rectificationResolutionFactor = Math.max(0.1, Math.min(1.0, factor));
                console.log(`Rectification resolution factor set to: ${rectificationResolutionFactor}`);
            }
            
            function toggleNearestNeighborInterpolation() {
                useNearestNeighborInterpolation = !useNearestNeighborInterpolation;
                console.log(`Nearest neighbor interpolation ${useNearestNeighborInterpolation ? 'enabled' : 'disabled'}`);
                return useNearestNeighborInterpolation;
            }
            
            let liveRectificationInterval = null;
            let edgeDetectionInterval = null;
            
            function startLiveRectification() {
                // Start live rectification updates
                if (liveRectificationInterval) {
                    clearInterval(liveRectificationInterval);
                }
                
                liveRectificationInterval = setInterval(() => {
                    if (selectedPoints.length === 4) {
                        updateLiveRectification();
                        updateEdgeDetection();
                    }
                }, edgeDetectionIntervalMs); // Configurable update interval for performance
                
                // Start edge detection updates (less frequent)
                if (edgeDetectionInterval) {
                    clearInterval(edgeDetectionInterval);
                }
                
                
            }
            
            function stopLiveRectification() {
                if (liveRectificationInterval) {
                    clearInterval(liveRectificationInterval);
                    liveRectificationInterval = null;
                }
                if (edgeDetectionInterval) {
                    clearInterval(edgeDetectionInterval);
                    edgeDetectionInterval = null;
                }
            }
            
            function updateLiveRectification() {
                if (selectedPoints.length !== 4) return;
                
                const video = document.getElementById('webcam-video');
                
                // Check if video is ready and has proper dimensions
                if (!video || video.videoWidth === 0 || video.videoHeight === 0) {
                    return; // Skip if video not ready
                }
                
                // Performance measurement: Start rectification timing
                const rectificationStart = performance.now();
                
                const sourceCanvas = document.createElement('canvas');
                const sourceCtx = sourceCanvas.getContext('2d');
                
                // Set source canvas size to match video
                sourceCanvas.width = video.videoWidth;
                sourceCanvas.height = video.videoHeight;
                
                // Draw current video frame to source canvas
                sourceCtx.drawImage(video, 0, 0);
                
                // Get the source points (trapezoid corners)
                const sortedPoints = sortPointsClockwise(selectedPoints);
                
                // Scale points to match video dimensions
                const videoRect = video.getBoundingClientRect();
                const scaleX = video.videoWidth / videoRect.width;
                const scaleY = video.videoHeight / videoRect.height;
                
                const sourcePoints = sortedPoints.map(point => ({
                    x: point.x * scaleX,
                    y: point.y * scaleY
                }));
                
                // Define destination points (rectangle corners)
                const destWidth = rectifiedCanvas.width;
                const destHeight = rectifiedCanvas.height;
                const destPoints = [
                    { x: 0, y: 0 },                    // top-left
                    { x: destWidth, y: 0 },            // top-right
                    { x: destWidth, y: destHeight },   // bottom-right
                    { x: 0, y: destHeight }            // bottom-left
                ];
                
                // Calculate perspective transformation matrix (trapezoid -> rectangle)
                const transformMatrix = calculatePerspectiveTransform(sourcePoints, destPoints);
                
                // Calculate inverse matrix (rectangle -> trapezoid) for sampling
                const inverseMatrix = calculateInversePerspectiveTransform(transformMatrix);
                
                // Apply transformation to rectified canvas
                applyPerspectiveTransform(sourceCanvas, rectifiedCanvas, inverseMatrix);
                
                // Performance measurement: End rectification timing
                const rectificationEnd = performance.now();
                const rectificationTime = rectificationEnd - rectificationStart;
                
                // Initialize performance data if it doesn't exist
                if (!window.performanceData) {
                    window.performanceData = {
                        rectificationTimes: [],
                        edgeDetectionTimes: [],
                        cannyTimes: [],
                        analysisTimes: [],
                        drawTimes: [],
                        totalTimes: []
                    };
                }
                window.performanceData.rectificationTimes.push(rectificationTime);
                
                // Note: Edge detection is now handled separately by updateEdgeDetection()
            }
            
            function updateEdgeDetection() {
                if (selectedPoints.length !== 4 || !edgeDetectionEnabled) return;
                
                // Initialize performance data if it doesn't exist
                if (!window.performanceData) {
                    window.performanceData = {
                        rectificationTimes: [],
                        edgeDetectionTimes: [],
                        cannyTimes: [],
                        analysisTimes: [],
                        drawTimes: [],
                        totalTimes: []
                    };
                }
                
                // Performance measurement: Start edge detection timing
                const edgeDetectionStart = performance.now();
                
                // Apply Canny edge detection to the current rectified canvas
                applyCannyEdgeDetection(rectifiedCanvas);
                
                // Performance measurement: End Canny edge detection timing
                const cannyEnd = performance.now();
                const cannyTime = cannyEnd - edgeDetectionStart;
                
                // Analyze perpendicular lines for outermost white pixels BEFORE drawing lines
                const analysisStart = performance.now();
                analyzePerpendicularLines();
                const analysisEnd = performance.now();
                const analysisTime = analysisEnd - analysisStart;
                
                // Redraw the draggable points and line after analysis
                const drawStart = performance.now();
                drawRectifiedPointsAndLine();
                const drawEnd = performance.now();
                const drawTime = drawEnd - drawStart;
                
                // Performance measurement: End total edge detection timing
                const edgeDetectionEnd = performance.now();
                const totalEdgeDetectionTime = edgeDetectionEnd - edgeDetectionStart;
                
                // Store timing for analysis
                window.performanceData.edgeDetectionTimes.push(totalEdgeDetectionTime);
                window.performanceData.cannyTimes.push(cannyTime);
                window.performanceData.analysisTimes.push(analysisTime);
                window.performanceData.drawTimes.push(drawTime);
                
                // Log performance data every 10 frames for analysis
                if (window.performanceData.edgeDetectionTimes && window.performanceData.edgeDetectionTimes.length % 10 === 0) {
                    console.log(`üîç Performance Analysis (Frame ${window.performanceData.edgeDetectionTimes.length}):`);
                    console.log(`  üìê Rectification: ${getAverageTime(window.performanceData.rectificationTimes || []).toFixed(2)}ms`);
                    console.log(`  üîç Canny Edge Detection: ${getAverageTime(window.performanceData.cannyTimes || []).toFixed(2)}ms`);
                    console.log(`  üìä Line Analysis: ${getAverageTime(window.performanceData.analysisTimes || []).toFixed(2)}ms`);
                    console.log(`  üé® Drawing: ${getAverageTime(window.performanceData.drawTimes || []).toFixed(2)}ms`);
                    console.log(`  ‚è±Ô∏è  Total Edge Detection: ${getAverageTime(window.performanceData.edgeDetectionTimes || []).toFixed(2)}ms`);
                }
            }
            
            function setupRectifiedCanvasInteraction() {
                rectifiedCanvas.onmousedown = function(event) {
                    const rect = event.target.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    
                    // Check if clicking on an existing draggable point
                    for (let i = 0; i < rectifiedPoints.length; i++) {
                        const point = rectifiedPoints[i];
                        const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                        if (distance <= 15) { // 15 pixel radius for dragging
                            isDraggingRectifiedPoint = true;
                            draggedRectifiedPointIndex = i;
                            rectifiedDragOffset.x = x - point.x;
                            rectifiedDragOffset.y = y - point.y;
                            return;
                        }
                    }
                };
                
                rectifiedCanvas.onmousemove = function(event) {
                    if (!isDraggingRectifiedPoint) return;
                    
                    const rect = event.target.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    
                    // Update the dragged point position
                    rectifiedPoints[draggedRectifiedPointIndex].x = x - rectifiedDragOffset.x;
                    rectifiedPoints[draggedRectifiedPointIndex].y = y - rectifiedDragOffset.y;
                    
                    // Redraw the points and line
                    drawRectifiedPointsAndLine();
                    
                    // Save the updated points position
                    saveRectifiedPoints();
                };
                
                rectifiedCanvas.onmouseup = function(event) {
                    if (isDraggingRectifiedPoint) {
                        isDraggingRectifiedPoint = false;
                        draggedRectifiedPointIndex = -1;
                        rectifiedDragOffset = { x: 0, y: 0 };
                    }
                };
                
                rectifiedCanvas.onmouseleave = function(event) {
                    // Stop dragging if mouse leaves the canvas area
                    if (isDraggingRectifiedPoint) {
                        isDraggingRectifiedPoint = false;
                        draggedRectifiedPointIndex = -1;
                        rectifiedDragOffset = { x: 0, y: 0 };
                    }
                };
            }
            
            function drawRectifiedPointsAndLine() {
                // Only draw if we have rectified content (4 points selected)
                if (selectedPoints.length !== 4) return;
                
                // Draw line between the two points
                rectifiedCtx.strokeStyle = '#00ff00';
                rectifiedCtx.lineWidth = 3;
                rectifiedCtx.beginPath();
                rectifiedCtx.moveTo(rectifiedPoints[0].x, rectifiedPoints[0].y);
                rectifiedCtx.lineTo(rectifiedPoints[1].x, rectifiedPoints[1].y);
                rectifiedCtx.stroke();
                
                // Calculate the main line vector and perpendicular direction
                const dx = rectifiedPoints[1].x - rectifiedPoints[0].x;
                const dy = rectifiedPoints[1].y - rectifiedPoints[0].y;
                const mainLineLength = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate perpendicular vector (rotated 90 degrees)
                const perpX = -dy / mainLineLength;
                const perpY = dx / mainLineLength;
                
                // Draw perpendicular lines (only for visual reference, not used in analysis)
                const numLines = reducedPerpendicularLines;
                rectifiedCtx.strokeStyle = '#ff00ff'; // Magenta color for perpendicular lines
                rectifiedCtx.lineWidth = 1;
                
                for (let i = 1; i < numLines; i++) {
                    // Calculate position along the main line
                    const t = i / numLines;
                    const x = rectifiedPoints[0].x + t * dx;
                    const y = rectifiedPoints[0].y + t * dy;
                    
                    // Calculate perpendicular line endpoints
                    const lineLength = 500; // Length of perpendicular lines
                    const startX = x - perpX * lineLength / 2;
                    const startY = y - perpY * lineLength / 2;
                    const endX = x + perpX * lineLength / 2;
                    const endY = y + perpY * lineLength / 2;
                    
                    // Draw perpendicular line
                    rectifiedCtx.beginPath();
                    rectifiedCtx.moveTo(startX, startY);
                    rectifiedCtx.lineTo(endX, endY);
                    rectifiedCtx.stroke();
                }
                
                // Draw the two draggable points
                rectifiedPoints.forEach((point, index) => {
                    // Draw point circle
                    rectifiedCtx.fillStyle = '#ff0000';
                    rectifiedCtx.beginPath();
                    rectifiedCtx.arc(point.x, point.y, 10, 0, 2 * Math.PI);
                    rectifiedCtx.fill();
                    
                    // Draw point border
                    rectifiedCtx.strokeStyle = '#ffffff';
                    rectifiedCtx.lineWidth = 2;
                    rectifiedCtx.stroke();
                    
                    // Draw point number
                    rectifiedCtx.fillStyle = '#ffffff';
                    rectifiedCtx.font = 'bold 14px Arial';
                    rectifiedCtx.textAlign = 'center';
                    rectifiedCtx.textBaseline = 'middle';
                    rectifiedCtx.fillText((index + 1).toString(), point.x, point.y);
                });
            }
            
            function analyzePerpendicularLines() {
                // Only analyze if we have rectified content and edge detection is enabled
                if (selectedPoints.length !== 4 || !edgeDetectionEnabled) return;
                
                // Get the edge-detected image data BEFORE any perpendicular lines are drawn
                const imageData = rectifiedCtx.getImageData(0, 0, rectifiedCanvas.width, rectifiedCanvas.height);
                
                // Calculate the main line vector and perpendicular direction
                const dx = rectifiedPoints[1].x - rectifiedPoints[0].x;
                const dy = rectifiedPoints[1].y - rectifiedPoints[0].y;
                const mainLineLength = Math.sqrt(dx * dx + dy * dy);
                
                // Prevent division by zero
                if (mainLineLength === 0) {
                    console.log("Main line has zero length, skipping analysis");
                    return;
                }
                
                // Calculate perpendicular vector (rotated 90 degrees)
                const perpX = -dy / mainLineLength;
                const perpY = dx / mainLineLength;
                
                // Array to store results for each perpendicular line
                const results = [];
                
                // Analyze each perpendicular line (reduced for performance)
                const numLines = reducedPerpendicularLines;
                for (let i = 1; i < numLines; i++) {
                    // Calculate position along the main line
                    const t = i / numLines;
                    const centerX = rectifiedPoints[0].x + t * dx;
                    const centerY = rectifiedPoints[0].y + t * dy;
                    
                    // Sample along the perpendicular line (reduced for performance)
                    const lineLength = 300; // Reduced from 500 to 300 pixels
                    const stepSize = 2; // Sample every 2 pixels instead of every pixel
                    const steps = Math.floor(lineLength / stepSize);
                    
                    let outermostWhiteAbove = null; // Distance above main line (positive)
                    let outermostWhiteBelow = null; // Distance below main line (negative)
                    
                    // Sample from center outward in both directions
                    // We need to find the OUTERMOST (farthest) white pixels, not just any white pixels
                    for (let step = 0; step <= steps / 2; step++) {
                        // Sample above the main line (positive direction)
                        const offsetAbove = step * stepSize;
                        const xAbove = centerX + perpX * offsetAbove;
                        const yAbove = centerY + perpY * offsetAbove;
                        
                        // Sample below the main line (negative direction)
                        const offsetBelow = step * stepSize;
                        const xBelow = centerX - perpX * offsetBelow;
                        const yBelow = centerY - perpY * offsetBelow;
                        
                        // Check if coordinates are within canvas bounds
                        if (xAbove >= 0 && xAbove < rectifiedCanvas.width && 
                            yAbove >= 0 && yAbove < rectifiedCanvas.height) {
                            
                            const pixelAbove = getPixelAt(imageData, Math.floor(xAbove), Math.floor(yAbove), rectifiedCanvas.width);
                            if (pixelAbove.r > 200) { // Higher threshold for true white pixels (edges should be 255)
                                // Keep the OUTERMOST (farthest from center) white pixel
                                outermostWhiteAbove = offsetAbove;
                                
                                // Draw detected point for visual debugging
                                if (visualDebugEnabled) {
                                    rectifiedCtx.fillStyle = '#00ff00'; // Green for detected edges
                                    rectifiedCtx.beginPath();
                                    rectifiedCtx.arc(xAbove, yAbove, 2, 0, 2 * Math.PI);
                                    rectifiedCtx.fill();
                                }
                            }
                        }
                        
                        if (xBelow >= 0 && xBelow < rectifiedCanvas.width && 
                            yBelow >= 0 && yBelow < rectifiedCanvas.height) {
                            
                            const pixelBelow = getPixelAt(imageData, Math.floor(xBelow), Math.floor(yBelow), rectifiedCanvas.width);
                            if (pixelBelow.r > 200) { // Higher threshold for true white pixels (edges should be 255)
                                // Keep the OUTERMOST (farthest from center) white pixel
                                outermostWhiteBelow = -offsetBelow; // Negative for below
                                
                                // Draw detected point for visual debugging
                                if (visualDebugEnabled) {
                                    rectifiedCtx.fillStyle = '#ff0000'; // Red for detected edges below
                                    rectifiedCtx.beginPath();
                                    rectifiedCtx.arc(xBelow, yBelow, 2, 0, 2 * Math.PI);
                                    rectifiedCtx.fill();
                                }
                            }
                        }
                    }
                    
                    // Determine the farthest white pixel from the main line
                    let farthestDistance = 0;
                    if (outermostWhiteAbove !== null && outermostWhiteBelow !== null) {
                        // Both sides have white pixels, choose the farther one
                        farthestDistance = Math.abs(outermostWhiteAbove) > Math.abs(outermostWhiteBelow) ? 
                                         outermostWhiteAbove : outermostWhiteBelow;
                    } else if (outermostWhiteAbove !== null) {
                        farthestDistance = outermostWhiteAbove;
                    } else if (outermostWhiteBelow !== null) {
                        farthestDistance = outermostWhiteBelow;
                    }
                    
                    results.push({
                        lineIndex: i,
                        position: t,
                        farthestDistance: farthestDistance,
                        hasWhitePixels: outermostWhiteAbove !== null || outermostWhiteBelow !== null,
                        debug: {
                            outermostWhiteAbove: outermostWhiteAbove,
                            outermostWhiteBelow: outermostWhiteBelow,
                            centerX: centerX,
                            centerY: centerY
                        }
                    });
                }
                
                // Extract just the distances array
                const distances = results.map(r => r.farthestDistance);
                
                // Check if this is a significant change from the last reading
                let hasSignificantChange = false;
                let isStable = false;
                
                if (perpendicularLineResults.length > 0) {
                    const lastDistances = perpendicularLineResults[perpendicularLineResults.length - 1].distances;
                    const changeResult = detectSignificantChange(distances, lastDistances);
                    hasSignificantChange = changeResult.isSignificant;
                    
                    // Simple stability logic
                    if (hasSignificantChange) {
                        // Over threshold = change detected, activate stability check
                        const totalChangeStr = isFinite(changeResult.totalChange) ? changeResult.totalChange.toFixed(1) : '‚àû';
                        const maxChangeStr = isFinite(changeResult.maxChange) ? changeResult.maxChange.toFixed(1) : '‚àû';
                        console.log(`üìä Change detected: total=${totalChangeStr}px, max=${maxChangeStr}px (threshold: ${changeThreshold}px) - stability check activated`);
                        stabilityReached = false; // Reset stability state
                        consecutiveStableReadings = 0; // Reset counter
                        document.getElementById('status-emoji').textContent = 'üîÑ';
                        document.getElementById('status-text').textContent = 'VER√ÑNDERUNG DETEKTEDIERT';
                    } else {
                        // Under threshold = no change, count up if stability check is active
                        if (!stabilityReached) {
                            consecutiveStableReadings++;
                            const totalChangeStr = isFinite(changeResult.totalChange) ? changeResult.totalChange.toFixed(1) : '‚àû';
                            console.log(`‚úÖ Stable reading ${consecutiveStableReadings}/${requiredStableReadings} (total change: ${totalChangeStr}px)`);
                            
                            document.getElementById('status-emoji').textContent = '‚öñÔ∏è';
                            document.getElementById('status-text').textContent = 'STABILISIERE BILD';

                            if (consecutiveStableReadings >= requiredStableReadings) {
                                console.log(`üéØüéØüéØ STABILITY DETECTED! üéØüéØüéØ`);
                                console.log(`üìà Readings have been stable for ${requiredStableReadings} consecutive measurements.`);
                                console.log(`üìã Stable distances:`, distances);
                                stabilityReached = true; // Mark stability as reached

                                // Map values between 0 and 1 for topDistances and bottomDistances
                                const maxTop = Math.max(...distances.map(d => d > 0 ? d : 0), 1);
                                const maxBottom = Math.max(...distances.map(d => d < 0 ? -d : 0), 1);
                                topDistances = distances.map(d => d > 0 ? (d / maxTop >= 0.5 ? 1 : 0) : 0);
                                bottomDistances = distances.map(d => d < 0 ? ((-d) / maxBottom >= 0.5 ? 1 : 0) : 0);

                                window.setPatterns(topDistances, bottomDistances);

                                document.getElementById('status-emoji').textContent = '‚úÖ';
                                document.getElementById('status-text').textContent = 'LINIE ERKANNT';
                            }
                        }
                    }
                } else {
                    hasSignificantChange = true; // First reading is always considered a change
                    console.log(`üîÑ First reading - stability tracking will start on next reading`);
                }
                
                // Only save and log if there's a significant change
                if (hasSignificantChange) {
                    const timestamp = new Date().toISOString();
                    const analysisResult = {
                        timestamp: timestamp,
                        distances: distances,
                        results: results // Keep full results for debugging if needed
                    };
                    
                    // Save to global array
                    perpendicularLineResults.push(analysisResult);
                    
                    // Keep only the last 100 analysis results to prevent memory issues
                    if (perpendicularLineResults.length > 100) {
                        perpendicularLineResults = perpendicularLineResults.slice(-100);
                    }
                    
                    // Log only the distances array
                    console.log(`[${timestamp}] Distances:`, distances);
                }
                
                return results;
            }
            
            function getPixelAt(imageData, x, y, width) {
                const index = (y * width + x) * 4;
                return {
                    r: imageData.data[index],
                    g: imageData.data[index + 1],
                    b: imageData.data[index + 2],
                    a: imageData.data[index + 3]
                };
            }
            
            function detectSignificantChange(currentDistances, lastDistances) {
                if (!lastDistances || currentDistances.length !== lastDistances.length) {
                    return { isSignificant: true, totalChange: Infinity, maxChange: Infinity }; // Different lengths = significant change
                }
                
                // Calculate cumulative/total change across all distances
                let totalChange = 0;
                let maxChange = 0;
                
                for (let i = 0; i < currentDistances.length; i++) {
                    const currentDist = currentDistances[i];
                    const lastDist = lastDistances[i];
                    const change = Math.abs(currentDist - lastDist);
                    
                    totalChange += change;
                    maxChange = Math.max(maxChange, change);
                }
                
                const isSignificant = totalChange >= changeThreshold;
                return { isSignificant: isSignificant, totalChange: totalChange, maxChange: maxChange };
            }
            
            // Helper functions to access the saved results
            function getAllPerpendicularResults() {
                return perpendicularLineResults;
            }
            
            function getLatestPerpendicularResults() {
                return perpendicularLineResults.length > 0 ? 
                       perpendicularLineResults[perpendicularLineResults.length - 1] : null;
            }
            
            function getPerpendicularResultsByIndex(index) {
                return perpendicularLineResults[index] || null;
            }
            
            function clearPerpendicularResults() {
                perpendicularLineResults = [];
                console.log('Perpendicular line results cleared');
            }
            
            // Threshold control functions
            function setChangeThreshold(threshold) {
                changeThreshold = threshold;
                console.log(`Change threshold set to: ${threshold} pixels`);
            }
            
            function getChangeThreshold() {
                return changeThreshold;
            }
            
            // Get just the distances arrays from all results
            function getAllDistances() {
                return perpendicularLineResults.map(result => result.distances);
            }
            
            // Get just the distances from the latest result
            function getLatestDistances() {
                const latest = getLatestPerpendicularResults();
                return latest ? latest.distances : null;
            }
            
            // Debug function to analyze the latest results
            function debugLatestResults() {
                const latest = getLatestPerpendicularResults();
                if (!latest) {
                    console.log("No results available yet");
                    return;
                }
                
                console.log("=== DEBUG: Latest Analysis Results ===");
                console.log("Timestamp:", latest.timestamp);
                console.log("Distances:", latest.distances);
                console.log("\nDetailed per-line analysis:");
                
                latest.results.forEach(result => {
                    if (result.hasWhitePixels) {
                        console.log(`Line ${result.lineIndex}: farthest=${result.farthestDistance.toFixed(1)}, above=${result.debug.outermostWhiteAbove}, below=${result.debug.outermostWhiteBelow}, center=(${result.debug.centerX.toFixed(1)}, ${result.debug.centerY.toFixed(1)})`);
                    } else {
                        console.log(`Line ${result.lineIndex}: no white pixels found, center=(${result.debug.centerX.toFixed(1)}, ${result.debug.centerY.toFixed(1)})`);
                    }
                });
                
                console.log("=== END DEBUG ===");
            }
            
            // Function to manually trigger analysis with debug output
            function debugAnalyzePerpendicularLines() {
                console.log("=== MANUAL DEBUG ANALYSIS ===");
                console.log("Rectified points:", rectifiedPoints);
                console.log("Edge detection enabled:", edgeDetectionEnabled);
                console.log("Selected points (4):", selectedPoints.length === 4);
                
                if (selectedPoints.length === 4 && edgeDetectionEnabled) {
                    const results = analyzePerpendicularLines();
                    debugLatestResults();
                } else {
                    console.log("Cannot analyze: missing requirements");
                }
            }
            
            // Function to analyze edge detection quality
            function debugEdgeDetection() {
                if (!edgeDetectionEnabled) {
                    console.log("Edge detection is not enabled");
                    return;
                }
                
                const imageData = rectifiedCtx.getImageData(0, 0, rectifiedCanvas.width, rectifiedCanvas.height);
                
                // Sample some pixels to see what values we're getting
                console.log("=== EDGE DETECTION ANALYSIS ===");
                console.log("Canvas size:", rectifiedCanvas.width, "x", rectifiedCanvas.height);
                
                // Sample a few pixels from different areas
                const samplePoints = [
                    { x: 50, y: 50, desc: "Top-left" },
                    { x: rectifiedCanvas.width/2, y: rectifiedCanvas.height/2, desc: "Center" },
                    { x: rectifiedCanvas.width-50, y: rectifiedCanvas.height-50, desc: "Bottom-right" }
                ];
                
                samplePoints.forEach(point => {
                    const pixel = getPixelAt(imageData, point.x, point.y, rectifiedCanvas.width);
                    console.log(`${point.desc} (${point.x}, ${point.y}): R=${pixel.r}, G=${pixel.g}, B=${pixel.b}`);
                });
                
                // Count white pixels in a small area
                let whitePixels = 0;
                let totalPixels = 0;
                for (let x = 100; x < 200; x++) {
                    for (let y = 100; y < 200; y++) {
                        const pixel = getPixelAt(imageData, x, y, rectifiedCanvas.width);
                        totalPixels++;
                        if (pixel.r > 200) whitePixels++;
                    }
                }
                console.log(`White pixel density in 100x100 area: ${whitePixels}/${totalPixels} (${(whitePixels/totalPixels*100).toFixed(1)}%)`);
                console.log("=== END EDGE DETECTION ANALYSIS ===");
            }
            
            // Visual debugging functions
            function enableVisualDebug() {
                visualDebugEnabled = true;
                console.log("Visual debugging enabled - detected edge points will be drawn on canvas");
            }
            
            function disableVisualDebug() {
                visualDebugEnabled = false;
                console.log("Visual debugging disabled");
            }
            
            function clearDebugOverlay() {
                // This will be called before each analysis to clear previous debug points
                // The main drawing function will redraw the perpendicular lines and points
                // We don't need to clear here since the edge detection redraws everything
            }
            
            function toggleVisualDebug() {
                visualDebugEnabled = !visualDebugEnabled;
                console.log(`Visual debugging ${visualDebugEnabled ? 'enabled' : 'disabled'}`);
                return visualDebugEnabled;
            }
            
            // Stability detection control functions
            function setRequiredStableReadings(count) {
                requiredStableReadings = count;
                console.log(`Required stable readings set to: ${count}`);
            }
            
            function getRequiredStableReadings() {
                return requiredStableReadings;
            }
            
            function getConsecutiveStableReadings() {
                return consecutiveStableReadings;
            }
            
            function resetStabilityCounter() {
                consecutiveStableReadings = 0;
                console.log("Stability counter reset");
            }
            
            function getStabilityStatus() {
                const status = {
                    consecutiveStableReadings: consecutiveStableReadings,
                    requiredStableReadings: requiredStableReadings,
                    threshold: changeThreshold,
                    totalReadings: perpendicularLineResults.length,
                    progress: `${consecutiveStableReadings}/${requiredStableReadings}`,
                    stabilityReached: stabilityReached
                };
                console.log("üìä Current Stability Status:", status);
                return status;
            }
            
            function resetStabilityState() {
                stabilityReached = false;
                consecutiveStableReadings = 0;
                console.log("üîÑ Stability state reset - tracking will resume on all readings");
            }
            
            function isStabilityReached() {
                return stabilityReached;
            }
            
            // Performance analysis helper functions
            function getAverageTime(times) {
                if (!times || !Array.isArray(times) || times.length === 0) return 0;
                const sum = times.reduce((sum, time) => sum + (time || 0), 0);
                return sum / times.length;
            }
            
            function getMaxTime(times) {
                if (!times || !Array.isArray(times) || times.length === 0) return 0;
                const validTimes = times.filter(time => typeof time === 'number' && !isNaN(time));
                return validTimes.length > 0 ? Math.max(...validTimes) : 0;
            }
            
            function getMinTime(times) {
                if (!times || !Array.isArray(times) || times.length === 0) return 0;
                const validTimes = times.filter(time => typeof time === 'number' && !isNaN(time));
                return validTimes.length > 0 ? Math.min(...validTimes) : 0;
            }
            
            function getPerformanceReport() {
                if (!window.performanceData) {
                    console.log("No performance data available yet");
                    return;
                }
                
                const data = window.performanceData;
                console.log("=== PERFORMANCE ANALYSIS REPORT ===");
                console.log(`üìä Total frames analyzed: ${(data.edgeDetectionTimes || []).length}`);
                console.log("");
                console.log("üìê RECTIFICATION:");
                console.log(`  Average: ${getAverageTime(data.rectificationTimes || []).toFixed(2)}ms`);
                console.log(`  Min: ${getMinTime(data.rectificationTimes || []).toFixed(2)}ms`);
                console.log(`  Max: ${getMaxTime(data.rectificationTimes || []).toFixed(2)}ms`);
                console.log("");
                console.log("üîç EDGE DETECTION BREAKDOWN:");
                console.log(`  Canny Edge Detection:`);
                console.log(`    Average: ${getAverageTime(data.cannyTimes || []).toFixed(2)}ms`);
                console.log(`    Min: ${getMinTime(data.cannyTimes || []).toFixed(2)}ms`);
                console.log(`    Max: ${getMaxTime(data.cannyTimes || []).toFixed(2)}ms`);
                console.log(`  Line Analysis:`);
                console.log(`    Average: ${getAverageTime(data.analysisTimes || []).toFixed(2)}ms`);
                console.log(`    Min: ${getMinTime(data.analysisTimes || []).toFixed(2)}ms`);
                console.log(`    Max: ${getMaxTime(data.analysisTimes || []).toFixed(2)}ms`);
                console.log(`  Drawing:`);
                console.log(`    Average: ${getAverageTime(data.drawTimes || []).toFixed(2)}ms`);
                console.log(`    Min: ${getMinTime(data.drawTimes || []).toFixed(2)}ms`);
                console.log(`    Max: ${getMaxTime(data.drawTimes || []).toFixed(2)}ms`);
                console.log("");
                console.log("‚è±Ô∏è  TOTAL EDGE DETECTION:");
                console.log(`  Average: ${getAverageTime(data.edgeDetectionTimes || []).toFixed(2)}ms`);
                console.log(`  Min: ${getMinTime(data.edgeDetectionTimes || []).toFixed(2)}ms`);
                console.log(`  Max: ${getMaxTime(data.edgeDetectionTimes || []).toFixed(2)}ms`);
                console.log("");
                console.log("üéØ BOTTLENECK ANALYSIS:");
                const avgRect = getAverageTime(data.rectificationTimes || []);
                const avgCanny = getAverageTime(data.cannyTimes || []);
                const avgAnalysis = getAverageTime(data.analysisTimes || []);
                const avgDraw = getAverageTime(data.drawTimes || []);
                
                if (avgRect > avgCanny && avgRect > avgAnalysis && avgRect > avgDraw) {
                    console.log("  üö® RECTIFICATION is the main bottleneck!");
                } else if (avgCanny > avgAnalysis && avgCanny > avgDraw) {
                    console.log("  üö® CANNY EDGE DETECTION is the main bottleneck!");
                } else if (avgAnalysis > avgDraw) {
                    console.log("  üö® LINE ANALYSIS is the main bottleneck!");
                } else {
                    console.log("  üö® DRAWING is the main bottleneck!");
                }
                console.log("=== END REPORT ===");
            }
            
            function clearPerformanceData() {
                if (window.performanceData) {
                    window.performanceData.rectificationTimes = [];
                    window.performanceData.edgeDetectionTimes = [];
                    window.performanceData.cannyTimes = [];
                    window.performanceData.analysisTimes = [];
                    window.performanceData.drawTimes = [];
                    console.log("Performance data cleared");
                }
            }

            // Make functions globally accessible for debugging
            window.getPerpendicularResults = getAllPerpendicularResults;
            window.getLatestResults = getLatestPerpendicularResults;
            window.getResultsByIndex = getPerpendicularResultsByIndex;
            window.clearResults = clearPerpendicularResults;
            window.setThreshold = setChangeThreshold;
            window.getThreshold = getChangeThreshold;
            window.getAllDistances = getAllDistances;
            window.getLatestDistances = getLatestDistances;
            window.debugLatest = debugLatestResults;
            window.debugAnalyze = debugAnalyzePerpendicularLines;
            window.debugEdges = debugEdgeDetection;
            window.enableVisualDebug = enableVisualDebug;
            window.disableVisualDebug = disableVisualDebug;
            window.toggleVisualDebug = toggleVisualDebug;
            window.setRequiredStableReadings = setRequiredStableReadings;
            window.getRequiredStableReadings = getRequiredStableReadings;
            window.getConsecutiveStableReadings = getConsecutiveStableReadings;
            window.resetStabilityCounter = resetStabilityCounter;
            window.getStabilityStatus = getStabilityStatus;
            window.resetStabilityState = resetStabilityState;
            window.isStabilityReached = isStabilityReached;
            window.resetToDefaultPoints = resetToDefaultPoints;
            window.setDefaultTriangulationPoints = setDefaultTriangulationPoints;
            window.setDefaultGreenLinePoints = setDefaultGreenLinePoints;
            window.forceDefaultPoints = forceDefaultPoints;
            window.setPerformanceMode = setPerformanceMode;
            window.getPerformanceSettings = getPerformanceSettings;
            window.setEdgeDetectionInterval = setEdgeDetectionInterval;
            window.toggleReducedResolution = toggleReducedResolution;
            window.toggleReducedRectificationResolution = toggleReducedRectificationResolution;
            window.setRectificationResolutionFactor = setRectificationResolutionFactor;
            window.toggleNearestNeighborInterpolation = toggleNearestNeighborInterpolation;
            window.getPerformanceReport = getPerformanceReport;
            window.clearPerformanceData = clearPerformanceData;
            
            function performRectification() {
                if (selectedPoints.length !== 4) {
                    console.error('Need exactly 4 points for rectification');
                    return;
                }
                
                // Show the rectified section
                document.getElementById('rectified-section').style.display = 'block';
                
                // Perform one-time rectification
                updateLiveRectification();
                
                // Draw the draggable points and line
                drawRectifiedPointsAndLine();
                
                console.log('Rectification completed');
            }
            
            function calculatePerspectiveTransform(sourcePoints, destPoints) {
                // Calculate perspective transformation matrix using 4-point correspondence
                // This implements the standard perspective transformation algorithm
                // We want to map FROM sourcePoints (trapezoid) TO destPoints (rectangle)
                
                const A = [];
                const B = [];
                
                for (let i = 0; i < 4; i++) {
                    const src = sourcePoints[i];
                    const dst = destPoints[i];
                    
                    // Each point gives us 2 equations
                    // We're solving: dest = transform(source)
                    A.push([src.x, src.y, 1, 0, 0, 0, -dst.x * src.x, -dst.x * src.y]);
                    A.push([0, 0, 0, src.x, src.y, 1, -dst.y * src.x, -dst.y * src.y]);
                    
                    B.push(dst.x);
                    B.push(dst.y);
                }
                
                // Solve the system of equations using Gaussian elimination
                const h = solveLinearSystem(A, B);
                
                // Return transformation matrix
                return [
                    [h[0], h[1], h[2]],
                    [h[3], h[4], h[5]],
                    [h[6], h[7], 1]
                ];
            }
            
            function calculateInversePerspectiveTransform(matrix) {
                // Calculate the inverse of a 3x3 perspective transformation matrix
                const m = matrix;
                
                // Calculate determinant
                const det = m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) -
                           m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
                           m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);
                
                if (Math.abs(det) < 1e-10) {
                    console.error('Matrix is singular, cannot compute inverse');
                    return matrix; // Return original matrix as fallback
                }
                
                // Calculate inverse matrix
                const inv = [
                    [
                        (m[1][1] * m[2][2] - m[1][2] * m[2][1]) / det,
                        (m[0][2] * m[2][1] - m[0][1] * m[2][2]) / det,
                        (m[0][1] * m[1][2] - m[0][2] * m[1][1]) / det
                    ],
                    [
                        (m[1][2] * m[2][0] - m[1][0] * m[2][2]) / det,
                        (m[0][0] * m[2][2] - m[0][2] * m[2][0]) / det,
                        (m[0][2] * m[1][0] - m[0][0] * m[1][2]) / det
                    ],
                    [
                        (m[1][0] * m[2][1] - m[1][1] * m[2][0]) / det,
                        (m[0][1] * m[2][0] - m[0][0] * m[2][1]) / det,
                        (m[0][0] * m[1][1] - m[0][1] * m[1][0]) / det
                    ]
                ];
                
                return inv;
            }
            
            function solveLinearSystem(A, B) {
                // Simple Gaussian elimination for 8x8 system
                const n = A.length;
                
                // Forward elimination
                for (let i = 0; i < n; i++) {
                    // Find pivot
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) {
                            maxRow = k;
                        }
                    }
                    
                    // Swap rows
                    [A[i], A[maxRow]] = [A[maxRow], A[i]];
                    [B[i], B[maxRow]] = [B[maxRow], B[i]];
                    
                    // Make all rows below this one 0 in current column
                    for (let k = i + 1; k < n; k++) {
                        const factor = A[k][i] / A[i][i];
                        for (let j = i; j < n; j++) {
                            A[k][j] -= factor * A[i][j];
                        }
                        B[k] -= factor * B[i];
                    }
                }
                
                // Back substitution
                const x = new Array(n);
                for (let i = n - 1; i >= 0; i--) {
                    x[i] = B[i];
                    for (let j = i + 1; j < n; j++) {
                        x[i] -= A[i][j] * x[j];
                    }
                    x[i] /= A[i][i];
                }
                
                return x;
            }
            
            function applyPerspectiveTransform(sourceCanvas, destCanvas, inverseMatrix) {
                const sourceCtx = sourceCanvas.getContext('2d');
                const destCtx = destCanvas.getContext('2d');
                
                // Check if source canvas has valid dimensions
                if (sourceCanvas.width === 0 || sourceCanvas.height === 0) {
                    return; // Skip if source canvas is not ready
                }
                
                // Clear destination canvas
                destCtx.clearRect(0, 0, destCanvas.width, destCanvas.height);
                
                // OPTIMIZATION: Use reduced resolution for rectification if enabled
                let workingDestWidth = destCanvas.width;
                let workingDestHeight = destCanvas.height;
                let scaleBackUp = false;
                let scaleX = 1.0;
                let scaleY = 1.0;
                
                if (useReducedRectificationResolution) {
                    workingDestWidth = Math.floor(destCanvas.width * rectificationResolutionFactor);
                    workingDestHeight = Math.floor(destCanvas.height * rectificationResolutionFactor);
                    scaleX = destCanvas.width / workingDestWidth;
                    scaleY = destCanvas.height / workingDestHeight;
                    scaleBackUp = true;
                }
                
                // Get source image data
                const sourceImageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
                const destImageData = destCtx.createImageData(workingDestWidth, workingDestHeight);
                
                // Use inverse transformation: for each destination pixel, find where to sample from in source
                // This ensures we fill every pixel in the destination with proper interpolation
                
                for (let destY = 0; destY < workingDestHeight; destY++) {
                    for (let destX = 0; destX < workingDestWidth; destX++) {
                        // Scale coordinates to full resolution for proper transformation
                        const fullResX = destX * scaleX;
                        const fullResY = destY * scaleY;
                        
                        // Transform destination point back to source coordinates (trapezoid)
                        const sourcePoint = transformPointInverse(fullResX, fullResY, inverseMatrix);
                        
                        // Check if source point is within bounds
                        if (sourcePoint.x >= 0 && sourcePoint.x < sourceCanvas.width &&
                            sourcePoint.y >= 0 && sourcePoint.y < sourceCanvas.height) {
                            
                            // OPTIMIZATION: Choose interpolation method based on settings
                            let pixel;
                            if (useNearestNeighborInterpolation) {
                                // Faster but lower quality - just round to nearest pixel
                                pixel = getPixel(sourceImageData, Math.round(sourcePoint.x), Math.round(sourcePoint.y), sourceCanvas.width);
                            } else {
                                // Higher quality bilinear interpolation
                                pixel = getBilinearPixel(sourceImageData, sourcePoint.x, sourcePoint.y, sourceCanvas.width, sourceCanvas.height);
                            }
                            
                            // Set pixel in destination
                            const destIndex = (destY * workingDestWidth + destX) * 4;
                            destImageData.data[destIndex] = pixel.r;     // Red
                            destImageData.data[destIndex + 1] = pixel.g; // Green
                            destImageData.data[destIndex + 2] = pixel.b; // Blue
                            destImageData.data[destIndex + 3] = pixel.a; // Alpha
                        }
                    }
                }
                
                if (scaleBackUp) {
                    // Create a temporary canvas for the reduced resolution result
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = workingDestWidth;
                    tempCanvas.height = workingDestHeight;
                    tempCtx.putImageData(destImageData, 0, 0);
                    
                    // Scale back up to original size using canvas scaling (much faster than pixel-by-pixel)
                    destCtx.imageSmoothingEnabled = true;
                    destCtx.imageSmoothingQuality = 'low'; // Faster scaling
                    destCtx.drawImage(tempCanvas, 0, 0, destCanvas.width, destCanvas.height);
                } else {
                    // Put the transformed image data directly to destination canvas
                    destCtx.putImageData(destImageData, 0, 0);
                }
            }
            
            function transformPointInverse(x, y, matrix) {
                // Apply inverse perspective transformation: destination -> source
                // For perspective transformation, we need to solve:
                // [x'] = [h0 h1 h2] [x]
                // [y']   [h3 h4 h5] [y]
                // [w']   [h6 h7 h8] [1]
                // Then x = x'/w', y = y'/w'
                
                const h = matrix;
                const w = h[2][0] * x + h[2][1] * y + h[2][2];
                
                if (Math.abs(w) < 1e-10) {
                    return { x: 0, y: 0 };
                }
                
                const sourceX = (h[0][0] * x + h[0][1] * y + h[0][2]) / w;
                const sourceY = (h[1][0] * x + h[1][1] * y + h[1][2]) / w;
                
                return { x: sourceX, y: sourceY };
            }
            
            function getBilinearPixel(imageData, x, y, width, height) {
                // Bilinear interpolation for smooth sampling
                const x1 = Math.floor(x);
                const y1 = Math.floor(y);
                const x2 = Math.min(x1 + 1, width - 1);
                const y2 = Math.min(y1 + 1, height - 1);
                
                const fx = x - x1;
                const fy = y - y1;
                
                // Get the four surrounding pixels
                const p1 = getPixel(imageData, x1, y1, width);
                const p2 = getPixel(imageData, x2, y1, width);
                const p3 = getPixel(imageData, x1, y2, width);
                const p4 = getPixel(imageData, x2, y2, width);
                
                // Interpolate
                const r = Math.round(
                    p1.r * (1 - fx) * (1 - fy) +
                    p2.r * fx * (1 - fy) +
                    p3.r * (1 - fx) * fy +
                    p4.r * fx * fy
                );
                
                const g = Math.round(
                    p1.g * (1 - fx) * (1 - fy) +
                    p2.g * fx * (1 - fy) +
                    p3.g * (1 - fx) * fy +
                    p4.g * fx * fy
                );
                
                const b = Math.round(
                    p1.b * (1 - fx) * (1 - fy) +
                    p2.b * fx * (1 - fy) +
                    p3.b * (1 - fx) * fy +
                    p4.b * fx * fy
                );
                
                const a = Math.round(
                    p1.a * (1 - fx) * (1 - fy) +
                    p2.a * fx * (1 - fy) +
                    p3.a * (1 - fx) * fy +
                    p4.a * fx * fy
                );
                
                return { r, g, b, a };
            }
            
            function getPixel(imageData, x, y, width) {
                const index = (y * width + x) * 4;
                return {
                    r: imageData.data[index],
                    g: imageData.data[index + 1],
                    b: imageData.data[index + 2],
                    a: imageData.data[index + 3]
                };
            }
            
            function applyCannyEdgeDetection(canvas) {
                const ctx = canvas.getContext('2d');
                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let workingWidth = canvas.width;
                let workingHeight = canvas.height;
                
                // Optionally reduce resolution for faster processing
                if (useReducedResolution) {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = Math.floor(canvas.width * reducedResolutionFactor);
                    tempCanvas.height = Math.floor(canvas.height * reducedResolutionFactor);
                    workingWidth = tempCanvas.width;
                    workingHeight = tempCanvas.height;
                    
                    // Draw scaled down version
                    tempCtx.drawImage(canvas, 0, 0, workingWidth, workingHeight);
                    imageData = tempCtx.getImageData(0, 0, workingWidth, workingHeight);
                }
                
                // Create jsfeat matrices for processing
                const src = new jsfeat.matrix_t(workingWidth, workingHeight, jsfeat.U8_t | jsfeat.C1_t);
                const dst = new jsfeat.matrix_t(workingWidth, workingHeight, jsfeat.U8_t | jsfeat.C1_t);
                
                // Convert RGBA to grayscale (optimized loop)
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    // Faster grayscale conversion using bit shifting
                    const gray = (data[i] * 77 + data[i + 1] * 150 + data[i + 2] * 29) >> 8;
                    src.data[i >> 2] = gray;
                }
                
                // Apply Gaussian blur with reduced kernel size for performance
                const blurred = new jsfeat.matrix_t(workingWidth, workingHeight, jsfeat.U8_t | jsfeat.C1_t);
                jsfeat.imgproc.gaussian_blur(src, blurred, 0.8); // Reduced blur radius
                
                // Apply Canny edge detection with optimized thresholds
                jsfeat.imgproc.canny(blurred, dst, optimizedCannyThresholds.low, optimizedCannyThresholds.high);
                
                // Convert back to RGBA and apply to canvas
                if (useReducedResolution) {
                    // Scale back up to original canvas size
                    const resultImageData = ctx.createImageData(canvas.width, canvas.height);
                    const scaleX = canvas.width / workingWidth;
                    const scaleY = canvas.height / workingHeight;
                    
                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const srcX = Math.floor(x / scaleX);
                            const srcY = Math.floor(y / scaleY);
                            const srcIndex = srcY * workingWidth + srcX;
                            const dstIndex = (y * canvas.width + x) * 4;
                            
                            const edgeValue = dst.data[srcIndex];
                            resultImageData.data[dstIndex] = edgeValue;     // Red
                            resultImageData.data[dstIndex + 1] = edgeValue; // Green
                            resultImageData.data[dstIndex + 2] = edgeValue; // Blue
                            resultImageData.data[dstIndex + 3] = 255;       // Alpha
                        }
                    }
                    ctx.putImageData(resultImageData, 0, 0);
                } else {
                    // Direct application to canvas
                    const resultImageData = ctx.createImageData(canvas.width, canvas.height);
                    for (let i = 0; i < dst.data.length; i++) {
                        const edgeValue = dst.data[i];
                        const pixelIndex = i * 4;
                        resultImageData.data[pixelIndex] = edgeValue;     // Red
                        resultImageData.data[pixelIndex + 1] = edgeValue; // Green
                        resultImageData.data[pixelIndex + 2] = edgeValue; // Blue
                        resultImageData.data[pixelIndex + 3] = 255;       // Alpha
                    }
                    ctx.putImageData(resultImageData, 0, 0);
                }
            }
            
            function transformPointForward(x, y, matrix) {
                // Apply forward perspective transformation: source -> destination
                const h = matrix;
                const w = h[2][0] * x + h[2][1] * y + h[2][2];
                
                if (Math.abs(w) < 1e-10) {
                    return { x: 0, y: 0 };
                }
                
                const destX = (h[0][0] * x + h[0][1] * y + h[0][2]) / w;
                const destY = (h[1][0] * x + h[1][1] * y + h[1][2]) / w;
                
                return { x: destX, y: destY };
            }
            
            function isPointInTrapezoid(x, y, points) {
                // Check if point (x, y) is inside the trapezoid defined by the 4 points
                // Using ray casting algorithm (point-in-polygon test)
                
                let inside = false;
                for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                    if (((points[i].y > y) !== (points[j].y > y)) &&
                        (x < (points[j].x - points[i].x) * (y - points[i].y) / (points[j].y - points[i].y) + points[i].x)) {
                        inside = !inside;
                    }
                }
                return inside;
            }
            
            // Initialize Sketch.js code
            function initializeSketch() {
                // Set background color
                document.body.style.backgroundColor = 'black';
                
                // Access the global sketch variables
                let mode = window.sketchVars.mode;
                
                function makePattern(pattern, height, rot, col){
                    let groupHeight = pattern.length*2*height;
                    let directionLine = new paper.Path.Line(paper.view.bounds.topLeft, paper.view.bounds.bottomRight);
                    directionLine.strokeColor = "red";
                    directionLine.rotate(rot);
                    
                    let patternGroup = new paper.Group();
                    for(let [idx, i] of Object.entries(pattern)){
                        let r = new paper.Path.Rectangle([0,idx*height], [paper.view.bounds.width*2, height]);
                        r.fillColor = col;
                        r.opacity = i;
                        r.blendMode = window.sketchVars.mode;
                        patternGroup.addChild(r);
                    }
                    for(let [idx, i] of Object.entries(pattern)){
                        let r = new paper.Path.Rectangle([0,idx*height+groupHeight/2], [paper.view.bounds.width*2, height]);
                        r.fillColor = col;
                        r.opacity = pattern[pattern.length-idx-1];
                        r.blendMode = window.sketchVars.mode;
                        patternGroup.addChild(r);
                    }
                    patternGroup.rotate(directionLine.getNormalAt(10).angle);
                    
                    let patternSymbol = new paper.Symbol(patternGroup);
                    for(let i = 0; i<directionLine.length;i+=groupHeight){
                        console.log(i);
                        patternSymbol.place(directionLine.getPointAt(i));
                        console.log(directionLine.getTangentAt(i).angle);
                    }
                }

                function getRandomTest(nr){
                    let pattern = [];
                    for(let i = 0; i<nr; i++){
                        pattern.push(Math.round(Math.random()));
                    }
                    return pattern;
                }

                let p = getRandomTest(10);
                makePattern(p, 40, 0, 'white');
                makePattern(p, 40, 120, 'white');
                makePattern(p, 40, 240, 'white');
                    
                makePattern(p, 100, 0, 'red');
                makePattern(p, 100, 120, 'red');
                makePattern(p, 100, 240, 'red');

                // Set up the animation frame
                function onFrame(e){
                   view.rotate(0.05);
                }
                
                // Start the animation
                paper.view.onFrame = onFrame;
            }
            
    </script>
</body>
</html>
